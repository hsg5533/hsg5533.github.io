{"version":3,"file":"static/js/81.4b586e7c.chunk.js","mappings":"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","sources":["pages/Finder.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\r\nimport * as ort from \"onnxruntime-web\";\r\n\r\nimport \"../assets/css/finder.css\";\r\n\r\nconst detectionConfidence = 0.6; // 탐지 신뢰도 임계값\r\nconst maskThreshold = 0.9; // 마스크 이진화 임계값\r\nconst fixedInferenceFps = 10; // 고정 추론 FPS 설정 (0 또는 음수는 무제한)\r\nconst modelInputWidth = 384; // 모델 입력 넓이 크기\r\nconst modelInputHeight = 384; // 모델 입력 높이 크기\r\n// 마스크 색상 설정\r\nconst maskColor = { r: 255, g: 255, b: 0, a: 0.3 };\r\nfunction sigmoid(x: number) {\r\n  return 1 / (1 + Math.exp(-x));\r\n}\r\n// 값을 min과 max 사이로 클램프\r\nfunction clamp(value: number, min: number, max: number) {\r\n  return Math.max(min, Math.min(max, value));\r\n}\r\n\r\nexport default function Finder() {\r\n  useEffect(() => {\r\n    const videoElement = document.getElementById(\"video\") as HTMLVideoElement;\r\n    const overlayCanvas = document.getElementById(\r\n      \"overlay\",\r\n    ) as HTMLCanvasElement;\r\n    const overlayContext = overlayCanvas.getContext(\"2d\", {\r\n      willReadFrequently: true,\r\n    }) as CanvasRenderingContext2D;\r\n    const modelInputCanvas = document.createElement(\"canvas\");\r\n    const modelInputContext = modelInputCanvas.getContext(\"2d\", {\r\n      willReadFrequently: true,\r\n    }) as CanvasRenderingContext2D;\r\n    // 전체 마스크 색상용 캔버스\r\n    const maskColorCanvas = document.createElement(\"canvas\");\r\n    const maskColorContext = maskColorCanvas.getContext(\"2d\", {\r\n      willReadFrequently: true,\r\n    }) as CanvasRenderingContext2D;\r\n    let frame: number | null = null;\r\n    let isBusy = false;\r\n    let isRunning = false;\r\n    let lastTimestamp = 0;\r\n    let lastUiUpdate = 0; // 화면 표시 갱신 주기용\r\n    let lastInfer = 0; // 전체(전처리+run+후처리) ms\r\n    let lastRun = 0; // run()만 ms\r\n    let ortSession: ort.InferenceSession | null = null;\r\n    let modelInputName: string | null = null;\r\n    const clearOverlay = () => {\r\n      overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);\r\n    };\r\n    const stopMediaStream = () => {\r\n      if (!videoElement.srcObject) return;\r\n      for (const track of (videoElement.srcObject as MediaStream).getTracks()) {\r\n        track.stop();\r\n      }\r\n      videoElement.srcObject = null;\r\n    };\r\n    const resizeOverlayToVideo = () => {\r\n      const videoRect = videoElement.getBoundingClientRect();\r\n      const { videoWidth, videoHeight } = videoElement;\r\n      overlayCanvas.style.position = \"absolute\";\r\n      overlayCanvas.style.width = `${Math.round(videoRect.width)}px`;\r\n      overlayCanvas.style.height = `${Math.round(videoRect.height)}px`;\r\n      overlayCanvas.style.top = `${Math.round(\r\n        videoRect.top + window.scrollY,\r\n      )}px`;\r\n      overlayCanvas.style.left = `${Math.round(\r\n        videoRect.left + window.scrollX,\r\n      )}px`;\r\n      overlayCanvas.style.pointerEvents = \"none\";\r\n      if (overlayCanvas.width !== videoWidth) overlayCanvas.width = videoWidth;\r\n      if (overlayCanvas.height !== videoHeight)\r\n        overlayCanvas.height = videoHeight;\r\n    };\r\n    const inferenceLoop = async (timestamp: number) => {\r\n      if (!isRunning) return;\r\n      frame = requestAnimationFrame(inferenceLoop);\r\n      const minDelta = 1000 / Math.max(1, fixedInferenceFps);\r\n      if (isBusy || timestamp - lastTimestamp < minDelta) return;\r\n      lastTimestamp = timestamp;\r\n      isBusy = true;\r\n      let detectionTensor = null;\r\n      let prototypeTensor = null;\r\n      const start = performance.now();\r\n      try {\r\n        const { videoWidth, videoHeight } = videoElement;\r\n        const inferenceFrameWidth = Math.round(\r\n          (videoWidth / videoHeight) * modelInputHeight,\r\n        );\r\n        const letterboxScale = Math.min(\r\n          1,\r\n          modelInputWidth / inferenceFrameWidth,\r\n        );\r\n        const letterboxNewWidth = Math.round(\r\n          inferenceFrameWidth * letterboxScale,\r\n        );\r\n        const letterboxNewHeight = Math.round(\r\n          modelInputHeight * letterboxScale,\r\n        );\r\n        const letterboxOffsetX = Math.floor(\r\n          (modelInputWidth - letterboxNewWidth) / 2,\r\n        );\r\n        const letterboxOffsetY = Math.floor(\r\n          (modelInputHeight - letterboxNewHeight) / 2,\r\n        );\r\n        const frameToVideoScaleX = videoWidth / inferenceFrameWidth;\r\n        const frameToVideoScaleY = videoHeight / modelInputHeight;\r\n        const canvasScaleX = overlayCanvas.width / videoWidth;\r\n        const canvasScaleY = overlayCanvas.height / videoHeight;\r\n        modelInputCanvas.width = modelInputWidth;\r\n        modelInputCanvas.height = modelInputHeight;\r\n        modelInputContext.imageSmoothingEnabled = true;\r\n        modelInputContext.fillStyle = \"rgb(114,114,114)\";\r\n        modelInputContext.fillRect(0, 0, modelInputWidth, modelInputHeight);\r\n        modelInputContext.drawImage(\r\n          videoElement,\r\n          0,\r\n          0,\r\n          videoWidth,\r\n          videoHeight,\r\n          letterboxOffsetX,\r\n          letterboxOffsetY,\r\n          letterboxNewWidth,\r\n          letterboxNewHeight,\r\n        );\r\n        const bmp = await createImageBitmap(modelInputCanvas);\r\n        const inputTensor = await ort.Tensor.fromImage(bmp, {\r\n          tensorFormat: \"RGB\",\r\n          tensorLayout: \"NCHW\",\r\n          dataType: \"float32\",\r\n          norm: { mean: 255, bias: 0 },\r\n        });\r\n        bmp.close();\r\n        if (!ortSession || !modelInputName) return;\r\n        const end = performance.now();\r\n        const outputs = await ortSession.run({\r\n          [modelInputName]: inputTensor,\r\n        });\r\n        lastRun = performance.now() - end; // 추론 시간 기록\r\n        inputTensor.dispose(); // 메모리 해제\r\n        for (const tensor of Object.values(outputs)) {\r\n          if (tensor.dims.length === 3 && tensor.dims[0] === 1) {\r\n            const boxCount = Math.max(tensor.dims[1], tensor.dims[2]);\r\n            if (\r\n              boxCount >= 1000 &&\r\n              Math.min(tensor.dims[1], tensor.dims[2]) >= 8 &&\r\n              (!detectionTensor ||\r\n                boxCount >\r\n                  Math.max(detectionTensor.dims[1], detectionTensor.dims[2]))\r\n            )\r\n              detectionTensor = tensor;\r\n          }\r\n          if (tensor.dims.length === 4 && tensor.dims[0] === 1) {\r\n            const nm = tensor.dims[1]; // 마스크 채널 수\r\n            const mh = tensor.dims[2]; // 마스크 높이\r\n            const mw = tensor.dims[3]; // 마스크 넓이\r\n            if (\r\n              nm >= 8 &&\r\n              mh >= 16 &&\r\n              mw >= 16 &&\r\n              (!prototypeTensor ||\r\n                mh * mw > prototypeTensor.dims[2] * prototypeTensor.dims[3])\r\n            )\r\n              prototypeTensor = tensor;\r\n          }\r\n        }\r\n        if (!detectionTensor || !prototypeTensor) return;\r\n        const detectionDims = detectionTensor.dims;\r\n        const prototypeDims = prototypeTensor.dims;\r\n        const detectionData = await detectionTensor.getData();\r\n        const prototypeData = (await prototypeTensor.getData()) as Float32Array;\r\n        detectionTensor.dispose();\r\n        prototypeTensor.dispose();\r\n        const numberOfMaskChannels = prototypeDims[1];\r\n        const dimA = detectionDims[1];\r\n        const dimB = detectionDims[2];\r\n        let getValue: (boxIndex: number, channelIndex: number) => number;\r\n        let numBoxes: number;\r\n        let numChannels: number;\r\n        if (dimA <= dimB) {\r\n          numChannels = dimA;\r\n          numBoxes = dimB;\r\n          getValue = (boxIndex, channelIndex) =>\r\n            (detectionData as Float32Array)[channelIndex * numBoxes + boxIndex];\r\n        } else {\r\n          numBoxes = dimA;\r\n          numChannels = dimB;\r\n          getValue = (boxIndex, channelIndex) =>\r\n            (detectionData as Float32Array)[\r\n              boxIndex * numChannels + channelIndex\r\n            ];\r\n        }\r\n        const parseVariant = (hasObjectness: boolean) => {\r\n          const classBaseIndex = hasObjectness ? 5 : 4;\r\n          const classCount =\r\n            numChannels - classBaseIndex - numberOfMaskChannels;\r\n          if (classCount <= 0) return [];\r\n          const coefBaseIndex = classBaseIndex + classCount;\r\n          const boxes = [];\r\n          for (let i = 0; i < numBoxes; i++) {\r\n            let centerX = getValue(i, 0);\r\n            let centerY = getValue(i, 1);\r\n            let width = getValue(i, 2);\r\n            let height = getValue(i, 3);\r\n            const looksNormalized =\r\n              centerX >= 0 &&\r\n              centerX <= 1.5 &&\r\n              centerY >= 0 &&\r\n              centerY <= 1.5 &&\r\n              width >= 0 &&\r\n              width <= 1.5 &&\r\n              height >= 0 &&\r\n              height <= 1.5;\r\n            if (looksNormalized) {\r\n              centerX *= modelInputWidth;\r\n              width *= modelInputWidth;\r\n              centerY *= modelInputHeight;\r\n              height *= modelInputHeight;\r\n            }\r\n            const objectnessRaw = hasObjectness ? getValue(i, 4) : 1.0;\r\n            const objectnessProb =\r\n              objectnessRaw >= 0 && objectnessRaw <= 1\r\n                ? objectnessRaw\r\n                : sigmoid(objectnessRaw);\r\n            let bestClassLogit = -1e9;\r\n            for (let c = 0; c < classCount; c++) {\r\n              const s = getValue(i, classBaseIndex + c);\r\n              if (s > bestClassLogit) bestClassLogit = s;\r\n            }\r\n            const classProb =\r\n              bestClassLogit >= 0 && bestClassLogit <= 1\r\n                ? bestClassLogit\r\n                : sigmoid(bestClassLogit);\r\n            const score = objectnessProb * classProb;\r\n            if (score < detectionConfidence) continue;\r\n            const x1 = centerX - width / 2;\r\n            const y1 = centerY - height / 2;\r\n            const x2 = centerX + width / 2;\r\n            const y2 = centerY + height / 2;\r\n            const maskCoefficients = new Float32Array(numberOfMaskChannels);\r\n            for (let k = 0; k < numberOfMaskChannels; k++) {\r\n              maskCoefficients[k] = getValue(i, coefBaseIndex + k);\r\n            }\r\n            boxes.push({ x1, y1, x2, y2, score, maskCoefficients });\r\n          }\r\n          return boxes;\r\n        };\r\n        const boxesWithoutObj = parseVariant(false);\r\n        const boxesWithObj = parseVariant(true);\r\n        const candidateBoxes =\r\n          boxesWithObj.length > boxesWithoutObj.length\r\n            ? boxesWithObj\r\n            : boxesWithoutObj;\r\n        if (!candidateBoxes.length) {\r\n          clearOverlay();\r\n          return;\r\n        }\r\n        candidateBoxes.sort((a, b) => b.score - a.score);\r\n        const bestBox = candidateBoxes[0];\r\n        const frameBoxX1 = clamp(\r\n          (bestBox.x1 - letterboxOffsetX) / letterboxScale,\r\n          0,\r\n          inferenceFrameWidth,\r\n        );\r\n        const frameBoxY1 = clamp(\r\n          (bestBox.y1 - letterboxOffsetY) / letterboxScale,\r\n          0,\r\n          modelInputHeight,\r\n        );\r\n        const frameBoxX2 = clamp(\r\n          (bestBox.x2 - letterboxOffsetX) / letterboxScale,\r\n          0,\r\n          inferenceFrameWidth,\r\n        );\r\n        const frameBoxY2 = clamp(\r\n          (bestBox.y2 - letterboxOffsetY) / letterboxScale,\r\n          0,\r\n          modelInputHeight,\r\n        );\r\n        const roiX0 = Math.max(0, Math.floor(frameBoxX1));\r\n        const roiY0 = Math.max(0, Math.floor(frameBoxY1));\r\n        const roiX1 = Math.min(inferenceFrameWidth, Math.floor(frameBoxX2));\r\n        const roiY1 = Math.min(modelInputHeight, Math.floor(frameBoxY2));\r\n        const roiWidth = roiX1 - roiX0 + 1;\r\n        const roiHeight = roiY1 - roiY0 + 1;\r\n        const drawX = roiX0 * frameToVideoScaleX * canvasScaleX;\r\n        const drawY = roiY0 * frameToVideoScaleY * canvasScaleY;\r\n        const drawW = roiWidth * frameToVideoScaleX * canvasScaleX;\r\n        const drawH = roiHeight * frameToVideoScaleY * canvasScaleY;\r\n        const inputRoiX = letterboxOffsetX + roiX0 * letterboxScale;\r\n        const inputRoiY = letterboxOffsetY + roiY0 * letterboxScale;\r\n        const inputRoiH = roiHeight * letterboxScale;\r\n        const inputRoiW = roiWidth * letterboxScale;\r\n        const protoMaskCount = prototypeDims[1];\r\n        const protoHeight = prototypeDims[2];\r\n        const protoWidth = prototypeDims[3];\r\n        const inputRoiX0 = clamp(Math.floor(inputRoiX), 0, modelInputWidth);\r\n        const inputRoiY0 = clamp(Math.floor(inputRoiY), 0, modelInputHeight);\r\n        const inputRoiX1 = clamp(\r\n          Math.ceil(inputRoiX + inputRoiW),\r\n          0,\r\n          modelInputWidth,\r\n        );\r\n        const inputRoiY1 = clamp(\r\n          Math.ceil(inputRoiY + inputRoiH),\r\n          0,\r\n          modelInputHeight,\r\n        );\r\n        const inputRoiWidth = inputRoiX1 - inputRoiX0;\r\n        const inputRoiHeight = inputRoiY1 - inputRoiY0;\r\n        const maskLogitThreshold = Math.log(\r\n          maskThreshold / (1 - maskThreshold),\r\n        );\r\n        const protoArea = protoHeight * protoWidth;\r\n        const binaryMask = new Uint8Array(roiWidth * roiHeight);\r\n        const modelInputToProtoScaleX = protoWidth / modelInputWidth;\r\n        const modelInputToProtoScaleY = protoHeight / modelInputHeight;\r\n        const roiToModelInputScaleX = inputRoiWidth / roiWidth;\r\n        const roiToModelInputScaleY = inputRoiHeight / roiHeight;\r\n        for (let roiY = 0; roiY < roiHeight; roiY++) {\r\n          // ROI 픽셀 중심을 modelInput 좌표로\r\n          const modelInputY = inputRoiY0 + (roiY + 0.5) * roiToModelInputScaleY;\r\n          const protoYFloat = modelInputY * modelInputToProtoScaleY;\r\n          const protoY0 = clamp(Math.floor(protoYFloat), 0, protoHeight);\r\n          const protoY1 = clamp(protoY0 + 1, 0, protoHeight);\r\n          const protoYFraction = protoYFloat - Math.floor(protoYFloat);\r\n          const protoYWeight0 = 1 - protoYFraction;\r\n          const protoYWeight1 = protoYFraction;\r\n          const protoRow0BaseIndex = protoY0 * protoWidth;\r\n          const protoRow1BaseIndex = protoY1 * protoWidth;\r\n          for (let roiX = 0; roiX < roiWidth; roiX++) {\r\n            const modelInputX =\r\n              inputRoiX0 + (roiX + 0.5) * roiToModelInputScaleX;\r\n            const protoXFloat = modelInputX * modelInputToProtoScaleX;\r\n            const protoX0 = clamp(Math.floor(protoXFloat), 0, protoWidth - 1);\r\n            const protoX1 = clamp(protoX0 + 1, 0, protoWidth - 1);\r\n            const protoXFraction = protoXFloat - Math.floor(protoXFloat);\r\n            const protoXWeight0 = 1 - protoXFraction;\r\n            const protoXWeight1 = protoXFraction;\r\n            const weight00 = protoXWeight0 * protoYWeight0;\r\n            const weight10 = protoXWeight1 * protoYWeight0;\r\n            const weight01 = protoXWeight0 * protoYWeight1;\r\n            const weight11 = protoXWeight1 * protoYWeight1;\r\n            const protoIndex00 = protoRow0BaseIndex + protoX0;\r\n            const protoIndex10 = protoRow0BaseIndex + protoX1;\r\n            const protoIndex01 = protoRow1BaseIndex + protoX0;\r\n            const protoIndex11 = protoRow1BaseIndex + protoX1;\r\n            let maskLogitValue = 0;\r\n            for (\r\n              let protoMaskChannelIndex = 0;\r\n              protoMaskChannelIndex < protoMaskCount;\r\n              protoMaskChannelIndex++\r\n            ) {\r\n              const protoChannelBaseIndex = protoMaskChannelIndex * protoArea;\r\n              const protoValue00 =\r\n                prototypeData[protoChannelBaseIndex + protoIndex00];\r\n              const protoValue10 =\r\n                prototypeData[protoChannelBaseIndex + protoIndex10];\r\n              const protoValue01 =\r\n                prototypeData[protoChannelBaseIndex + protoIndex01];\r\n              const protoValue11 =\r\n                prototypeData[protoChannelBaseIndex + protoIndex11];\r\n              const bilinearPrototypeValue =\r\n                protoValue00 * weight00 +\r\n                protoValue10 * weight10 +\r\n                protoValue01 * weight01 +\r\n                protoValue11 * weight11;\r\n              maskLogitValue +=\r\n                bestBox.maskCoefficients[protoMaskChannelIndex] *\r\n                bilinearPrototypeValue;\r\n            }\r\n            binaryMask[roiY * roiWidth + roiX] =\r\n              maskLogitValue >= maskLogitThreshold ? 1 : 0;\r\n          }\r\n        }\r\n        const boundary = []; // roi 마스크 경계 외곽선 좌표 배열값\r\n        for (let y = 1; y < roiHeight - 1; y++) {\r\n          const row = y * roiWidth;\r\n          for (let x = 1; x < roiWidth - 1; x++) {\r\n            const idx = row + x;\r\n            if (!binaryMask[idx]) continue;\r\n            const all =\r\n              binaryMask[idx - 1] &\r\n              binaryMask[idx + 1] &\r\n              binaryMask[idx - roiWidth] &\r\n              binaryMask[idx + roiWidth] &\r\n              binaryMask[idx - roiWidth - 1] &\r\n              binaryMask[idx - roiWidth + 1] &\r\n              binaryMask[idx + roiWidth - 1] &\r\n              binaryMask[idx + roiWidth + 1];\r\n\r\n            if (all === 0) boundary.push({ x, y });\r\n          }\r\n        }\r\n        boundary.sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));\r\n        const lower = []; // 아래쪽 경계(왼쪽→오른쪽으로 가는 하단 외곽선)\r\n        for (let i = 0; i < boundary.length; i++) {\r\n          const p = boundary[i];\r\n          while (lower.length >= 2) {\r\n            const o = lower[lower.length - 2];\r\n            const a = lower[lower.length - 1];\r\n            const cross = (a.x - o.x) * (p.y - o.y) - (a.y - o.y) * (p.x - o.x);\r\n            if (cross > 0) break;\r\n            lower.pop();\r\n          }\r\n          lower.push(p);\r\n        }\r\n        const upper = []; // 위쪽 경계(오른쪽→왼쪽으로 돌아오는 상단 외곽선)\r\n        for (let i = boundary.length - 1; i >= 0; i--) {\r\n          const p = boundary[i];\r\n          while (upper.length >= 2) {\r\n            const o = upper[upper.length - 2];\r\n            const a = upper[upper.length - 1];\r\n            const cross = (a.x - o.x) * (p.y - o.y) - (a.y - o.y) * (p.x - o.x);\r\n            if (cross > 0) break;\r\n            upper.pop();\r\n          }\r\n          upper.push(p);\r\n        }\r\n        // 좌측 끝, 우측끝 좌표 중복 방지\r\n        upper.pop();\r\n        lower.pop();\r\n        const hull = lower.concat(upper);\r\n        if (hull.length >= 4) {\r\n          const ring = hull.slice();\r\n          ring.push(hull[0]);\r\n          let per = 0;\r\n          for (let i = 0; i < ring.length - 1; i++) {\r\n            const a = ring[i],\r\n              b = ring[i + 1];\r\n            per += Math.hypot(b.x - a.x, b.y - a.y);\r\n          }\r\n          per = Math.max(1, per);\r\n          let eps = per * 0.01;\r\n          let simp = null;\r\n          for (let iter = 0; iter < 35; iter++) {\r\n            const n = ring.length;\r\n            const keep = new Uint8Array(n);\r\n            keep[0] = 1;\r\n            keep[n - 1] = 1;\r\n            const stack: number[][] = [];\r\n            stack.push([0, n - 1]);\r\n            while (stack.length) {\r\n              const [s, e] = stack.pop() as number[];\r\n              const ax = ring[s].x;\r\n              const ay = ring[s].y;\r\n              const bx = ring[e].x;\r\n              const by = ring[e].y;\r\n              const vx = bx - ax;\r\n              const vy = by - ay;\r\n              const vv = vx * vx + vy * vy;\r\n              let bestIdx = -1;\r\n              let bestDist = -1;\r\n              for (let i = s + 1; i < e; i++) {\r\n                const px = ring[i].x;\r\n                const py = ring[i].y;\r\n                let dist;\r\n                if (vv <= 1e-9) {\r\n                  dist = Math.hypot(px - ax, py - ay);\r\n                } else {\r\n                  const wx = px - ax;\r\n                  const wy = py - ay;\r\n                  let t = (wx * vx + wy * vy) / vv;\r\n                  if (t < 0) t = 0;\r\n                  else if (t > 1) t = 1;\r\n                  const cx = ax + t * vx;\r\n                  const cy = ay + t * vy;\r\n                  dist = Math.hypot(px - cx, py - cy);\r\n                }\r\n                if (dist > bestDist) {\r\n                  bestDist = dist;\r\n                  bestIdx = i;\r\n                }\r\n              }\r\n              if (bestDist > eps && bestIdx !== -1) {\r\n                keep[bestIdx] = 1;\r\n                stack.push([s, bestIdx]);\r\n                stack.push([bestIdx, e]);\r\n              }\r\n            }\r\n            const out = [];\r\n            for (let i = 0; i < n; i++) if (keep[i]) out.push(ring[i]);\r\n            out.pop(); // drop duplicated last\r\n            simp = out;\r\n            if (simp.length > 4) eps *= 1.25;\r\n            else if (simp.length < 4) eps *= 0.8;\r\n            else break;\r\n          }\r\n          if (!simp) return;\r\n          let qcx = 0;\r\n          let qcy = 0;\r\n          for (let i = 0; i < 4; i++) {\r\n            qcx += simp[i].x;\r\n            qcy += simp[i].y;\r\n          }\r\n          qcx /= 4;\r\n          qcy /= 4;\r\n          const sorted = simp\r\n            .slice()\r\n            .sort(\r\n              (p, q) =>\r\n                Math.atan2(p.y - qcy, p.x - qcx) -\r\n                Math.atan2(q.y - qcy, q.x - qcx),\r\n            );\r\n          let bestIdx = 0;\r\n          let bestVal = Infinity;\r\n          for (let i = 0; i < 4; i++) {\r\n            const v = sorted[i].x + sorted[i].y;\r\n            if (v < bestVal) {\r\n              bestVal = v;\r\n              bestIdx = i;\r\n            }\r\n          }\r\n          const tl = sorted[bestIdx];\r\n          const tr = sorted[(bestIdx + 1) % 4];\r\n          const br = sorted[(bestIdx + 2) % 4];\r\n          const bl = sorted[(bestIdx + 3) % 4];\r\n          const quadOnOverlay = [tl, tr, br, bl].map((p) => {\r\n            const fx = roiX0 + p.x; // inferenceFrame coords\r\n            const fy = roiY0 + p.y;\r\n            return {\r\n              x: fx * frameToVideoScaleX * canvasScaleX,\r\n              y: fy * frameToVideoScaleY * canvasScaleY,\r\n            };\r\n          });\r\n          clearOverlay();\r\n          overlayContext.save();\r\n          overlayContext.beginPath();\r\n          overlayContext.moveTo(quadOnOverlay[0].x, quadOnOverlay[0].y);\r\n          overlayContext.lineTo(quadOnOverlay[1].x, quadOnOverlay[1].y);\r\n          overlayContext.lineTo(quadOnOverlay[2].x, quadOnOverlay[2].y);\r\n          overlayContext.lineTo(quadOnOverlay[3].x, quadOnOverlay[3].y);\r\n          overlayContext.closePath();\r\n          overlayContext.strokeStyle = \"rgba(0,255,0,1)\";\r\n          overlayContext.lineWidth = 4;\r\n          overlayContext.stroke();\r\n          overlayContext.restore();\r\n        }\r\n        // 마스크 색상 오버레이 그리기\r\n        maskColorCanvas.width = roiWidth;\r\n        maskColorCanvas.height = roiHeight;\r\n        const maskColorImageData = maskColorContext.createImageData(\r\n          roiWidth,\r\n          roiHeight,\r\n        );\r\n        const out = maskColorImageData.data;\r\n        for (let i = 0; i < roiWidth * roiHeight; i++) {\r\n          const p = i * 4;\r\n          if (binaryMask[i]) {\r\n            out[p] = maskColor.r;\r\n            out[p + 1] = maskColor.g;\r\n            out[p + 2] = maskColor.b;\r\n            out[p + 3] = Math.min(255, Math.round(maskColor.a * 255));\r\n          } else {\r\n            out[p] = 0;\r\n            out[p + 1] = 0;\r\n            out[p + 2] = 0;\r\n            out[p + 3] = 0;\r\n          }\r\n        }\r\n        // 마스크 색상 오버레이 그리기\r\n        maskColorContext.putImageData(maskColorImageData, 0, 0);\r\n        overlayContext.save();\r\n        overlayContext.imageSmoothingEnabled = true;\r\n        // draw 마스크 색상 오버레이\r\n        overlayContext.drawImage(maskColorCanvas, drawX, drawY, drawW, drawH);\r\n        overlayContext.fillStyle = \"rgba(0,0,0,0.95)\";\r\n        overlayContext.font = `900 ${Math.round(\r\n          Math.min(overlayCanvas.width, overlayCanvas.height) * 0.06,\r\n        )}px system-ui`;\r\n        overlayContext.textAlign = \"center\";\r\n        overlayContext.textBaseline = \"middle\";\r\n        overlayContext.fillText(\r\n          `${Math.round(bestBox.score * 100)}%`,\r\n          drawX + drawW / 2,\r\n          drawY + drawH / 2,\r\n        );\r\n        overlayContext.restore();\r\n      } catch (error) {\r\n        if (error instanceof Error) {\r\n          console.error(error.message);\r\n        }\r\n      } finally {\r\n        isBusy = false;\r\n        lastInfer = performance.now() - start;\r\n        // 200ms마다 화면 표시 업데이트\r\n        if (timestamp - lastUiUpdate > 200) {\r\n          lastUiUpdate = timestamp;\r\n          // 화면에 텍스트로 표시\r\n          const status = document.getElementById(\"status\");\r\n          if (status) {\r\n            status.textContent = `사이클 ${lastInfer.toFixed(\r\n              1,\r\n            )}ms / 추론 ${lastRun.toFixed(1)}ms`;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    document.getElementById(\"start\")!!.addEventListener(\"click\", async () => {\r\n      try {\r\n        if (!ortSession) {\r\n          ortSession = await ort.InferenceSession.create(\"best.onnx\", {\r\n            executionProviders: [\"webgl\", \"wasm\"],\r\n            graphOptimizationLevel: \"all\",\r\n          });\r\n          modelInputName = ortSession.inputNames[0];\r\n        }\r\n        stopMediaStream();\r\n        videoElement.srcObject = await navigator.mediaDevices.getUserMedia({\r\n          audio: false,\r\n          video: {\r\n            facingMode: { ideal: \"environment\" },\r\n            width: { ideal: 1920 },\r\n            height: { ideal: 1080 },\r\n            frameRate: { ideal: 60 },\r\n          },\r\n        });\r\n        await videoElement.play();\r\n        resizeOverlayToVideo();\r\n        window.addEventListener(\"scroll\", resizeOverlayToVideo, {\r\n          passive: true,\r\n        });\r\n        window.addEventListener(\"resize\", resizeOverlayToVideo, {\r\n          passive: true,\r\n        });\r\n        window.addEventListener(\"orientationchange\", resizeOverlayToVideo, {\r\n          passive: true,\r\n        });\r\n        isBusy = false;\r\n        isRunning = true;\r\n        lastTimestamp = 0;\r\n        if (frame) cancelAnimationFrame(frame);\r\n        frame = requestAnimationFrame(inferenceLoop);\r\n      } catch (error) {\r\n        if (error instanceof Error) {\r\n          console.error(error.message);\r\n        }\r\n      }\r\n    });\r\n    document.getElementById(\"stop\")!!.addEventListener(\"click\", () => {\r\n      isRunning = false;\r\n      if (frame) cancelAnimationFrame(frame);\r\n      frame = null;\r\n      stopMediaStream();\r\n      videoElement.srcObject = null;\r\n      clearOverlay();\r\n      window.removeEventListener(\"scroll\", resizeOverlayToVideo);\r\n      window.removeEventListener(\"resize\", resizeOverlayToVideo);\r\n      window.removeEventListener(\"orientationchange\", resizeOverlayToVideo);\r\n    });\r\n    document.getElementById(\"switch\")!!.addEventListener(\"click\", async () => {\r\n      let camIndex = 0;\r\n      if (!videoElement.srcObject) return;\r\n      const devices = await navigator.mediaDevices.enumerateDevices();\r\n      const cams = devices.filter((device) => device.kind === \"videoinput\");\r\n      const id = (videoElement.srcObject as MediaStream)\r\n        .getVideoTracks()[0]\r\n        .getSettings().deviceId;\r\n      if (id) {\r\n        const idx = cams.findIndex((cam) => cam.deviceId === id);\r\n        if (idx >= 0) camIndex = (idx + 1) % cams.length;\r\n      }\r\n      stopMediaStream();\r\n      videoElement.srcObject = await navigator.mediaDevices.getUserMedia({\r\n        audio: false,\r\n        video: {\r\n          deviceId: { exact: cams[camIndex].deviceId }, // ✅ 핵심: deviceId 사용\r\n          width: { ideal: 1920 },\r\n          height: { ideal: 1080 },\r\n          frameRate: { ideal: 60 },\r\n        },\r\n      }); // ✅ 새 스트림을 video에 연결\r\n      await videoElement.play();\r\n      resizeOverlayToVideo();\r\n    });\r\n    return () => {\r\n      window.removeEventListener(\"scroll\", resizeOverlayToVideo);\r\n      window.removeEventListener(\"resize\", resizeOverlayToVideo);\r\n      window.removeEventListener(\"orientationchange\", resizeOverlayToVideo);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <video id=\"video\" playsInline autoPlay muted></video>\r\n      <canvas id=\"overlay\"></canvas>\r\n      <div className=\"hud-top\">\r\n        <button className=\"top-btn\" id=\"start\">\r\n          시작\r\n        </button>\r\n        <button className=\"top-btn\" id=\"stop\">\r\n          정지\r\n        </button>\r\n        <button className=\"top-btn\" id=\"switch\">\r\n          전환\r\n        </button>\r\n        <div id=\"status\"></div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n"],"names":["detectionConfidence","maskThreshold","fixedInferenceFps","modelInputWidth","modelInputHeight","maskColor","r","g","b","a","sigmoid","x","Math","exp","clamp","value","min","max","Finder","useEffect","videoElement","document","getElementById","overlayCanvas","overlayContext","getContext","willReadFrequently","modelInputCanvas","createElement","modelInputContext","maskColorCanvas","maskColorContext","frame","isBusy","isRunning","lastTimestamp","lastUiUpdate","lastInfer","lastRun","ortSession","modelInputName","clearOverlay","clearRect","width","height","stopMediaStream","srcObject","track","getTracks","stop","resizeOverlayToVideo","videoRect","getBoundingClientRect","videoWidth","videoHeight","style","position","round","top","window","scrollY","left","scrollX","pointerEvents","inferenceLoop","async","requestAnimationFrame","minDelta","timestamp","detectionTensor","prototypeTensor","start","performance","now","inferenceFrameWidth","letterboxScale","letterboxNewWidth","letterboxNewHeight","letterboxOffsetX","floor","letterboxOffsetY","frameToVideoScaleX","frameToVideoScaleY","canvasScaleX","canvasScaleY","imageSmoothingEnabled","fillStyle","fillRect","drawImage","bmp","createImageBitmap","inputTensor","ort","fromImage","tensorFormat","tensorLayout","dataType","norm","mean","bias","close","end","outputs","run","dispose","tensor","Object","values","dims","length","boxCount","nm","mh","mw","detectionDims","prototypeDims","detectionData","getData","prototypeData","numberOfMaskChannels","dimA","dimB","getValue","numBoxes","numChannels","boxIndex","channelIndex","parseVariant","hasObjectness","classBaseIndex","classCount","coefBaseIndex","boxes","i","centerX","centerY","objectnessRaw","objectnessProb","bestClassLogit","c","s","score","x1","y1","x2","y2","maskCoefficients","Float32Array","k","push","boxesWithoutObj","boxesWithObj","candidateBoxes","sort","bestBox","frameBoxX1","frameBoxY1","frameBoxX2","frameBoxY2","roiX0","roiY0","roiX1","roiY1","roiWidth","roiHeight","drawX","drawY","drawW","drawH","inputRoiX","inputRoiY","inputRoiH","inputRoiW","protoMaskCount","protoHeight","protoWidth","inputRoiX0","inputRoiY0","inputRoiX1","ceil","inputRoiY1","inputRoiWidth","inputRoiHeight","maskLogitThreshold","log","protoArea","binaryMask","Uint8Array","modelInputToProtoScaleX","modelInputToProtoScaleY","roiToModelInputScaleX","roiToModelInputScaleY","roiY","protoYFloat","protoY0","protoY1","protoYFraction","protoYWeight0","protoYWeight1","protoRow0BaseIndex","protoRow1BaseIndex","roiX","protoXFloat","protoX0","protoX1","protoXFraction","protoXWeight0","weight00","weight10","weight01","weight11","protoIndex00","protoIndex10","protoIndex01","protoIndex11","maskLogitValue","protoMaskChannelIndex","protoChannelBaseIndex","protoValue00","protoValue10","protoValue01","bilinearPrototypeValue","boundary","y","row","idx","lower","p","o","pop","upper","hull","concat","ring","slice","per","hypot","eps","simp","iter","n","keep","stack","e","ax","ay","bx","by","vx","vy","vv","bestIdx","bestDist","px","py","dist","t","cx","cy","out","qcx","qcy","sorted","q","atan2","bestVal","Infinity","v","tl","tr","br","quadOnOverlay","map","fx","fy","save","beginPath","moveTo","lineTo","closePath","strokeStyle","lineWidth","stroke","restore","maskColorImageData","createImageData","data","putImageData","font","textAlign","textBaseline","fillText","error","Error","console","message","status","textContent","toFixed","addEventListener","create","executionProviders","graphOptimizationLevel","inputNames","navigator","mediaDevices","getUserMedia","audio","video","facingMode","ideal","frameRate","play","passive","cancelAnimationFrame","removeEventListener","camIndex","cams","enumerateDevices","filter","device","kind","id","getVideoTracks","getSettings","deviceId","findIndex","cam","exact","_jsxs","className","children","_jsx","playsInline","autoPlay","muted"],"sourceRoot":""}